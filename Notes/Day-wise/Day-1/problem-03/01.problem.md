# ğŸ“˜ DAY 1 â€” PROGRAM 3 â€” FILE 1  
## ğŸ“„ problem.md  

---

# ğŸ”– Concepts Involved  
HashMap, Frequency Counting, Custom Ordering, Stable Sorting, Tie-Break Logic  

---

# ğŸ§© Title  
Frequency-Ordered Unique Extraction  

---

# ğŸ“– Problem Story / Context  

A data analytics system receives a stream of integers representing event IDs.  

Your task is to extract **unique event IDs** and return them ordered by:

1. **Higher frequency first**
2. If frequencies are equal â†’ **smaller value first**

The system must be efficient for large input sizes and must not rely on brute-force nested comparisons.

---

# ğŸ“¥ Inputs  

- An integer array `nums`
- Size `n` where `1 â‰¤ n â‰¤ 10^5`
- Values may be negative or positive (within 32-bit integer range)

---

# ğŸ“¤ Outputs  

- A vector of unique integers
- Ordered by:
  - Frequency descending
  - Value ascending (if tie)

---

# ğŸ“ Constraints  

- Time efficiency required for large `n`
- Sorting must respect dual-condition ordering
- Output must contain **only unique values**
- Frequency computation must be accurate
- No modification of original array required

---

# âš ï¸ Edge-Case Thinking Prompts  

- What if all values are identical?  
- What if all values are unique?  
- How should negative numbers be handled?  
- What if two numbers have equal frequency and equal value?  
- What if input size is 1?  
- What if input is empty?  

---

# ğŸ§ª Sample Inputs & Outputs  

### Sample 1  

**Input:**  
nums = [4, 6, 4, 3, 6, 4, 2]


**Output:**  
[4, 6, 2, 3]


**Explanation:**  
- 4 â†’ 3 times  
- 6 â†’ 2 times  
- 2 â†’ 1 time  
- 3 â†’ 1 time  
Between 2 and 3 â†’ same frequency â†’ smaller value first  

---

### Sample 2  

**Input:**  
nums = [10, -1, 10, 5, -1, 5]


**Output:**  
[-1, 5, 10]


**Explanation:**  
All values appear twice â†’ sort by value ascending  

---

# ğŸ§  Thinking Like a Programmer  

### ğŸ” What must be tracked?  
- Frequency of each value  
- Unique elements  
- Ordering rules  

### ğŸ”„ What can change?  
- Frequency counts while iterating  
- Order of elements before final sorting  

### ğŸ”’ What must never change?  
- Frequency accuracy  
- Ordering priority (frequency > value)  

### ğŸ¢ What brute force would do?  
- For each element, count occurrences by scanning entire array  
- O(NÂ²) approach  
- Repeated comparisons during sorting  

Why is this inefficient for large N?  
Can we reduce repeated scanning using memory?  

---