# 2ï¸âƒ£ solution.md â€” Execution Artifacts

> **ðŸ”– Header**
> **Concepts Used:** Linear Search, Array Iteration, Conditional Logic

---

## A. Executable Test Code

Use this test harness to verify the solution against various scenarios, including edge and stress cases.

```cpp

#include <iostream>
#include <vector>
#include <cassert>

// Include the solution class above or link during compilation
// (Assuming AttendanceLog class is visible here)

void runTests() {
    std::cout << "Running Test Harness..." << std::endl;

    // --- 1. Normal Case ---
    // ID exists in the middle of the list
    std::vector<int> normalList = {101, 204, 305, 402, 509};
    int result1 = AttendanceLog::findStudent(5, normalList, 305);
    assert(result1 == 2); 
    std::cout << "[PASS] Normal Case: Found 305 at index 2." << std::endl;

    // --- 2. Edge Case: Not Found ---
    int result2 = AttendanceLog::findStudent(5, normalList, 999);
    assert(result2 == -1);
    std::cout << "[PASS] Edge Case: 999 not found (-1)." << std::endl;

    // --- 3. Edge Case: Empty List ---
    std::vector<int> emptyList = {};
    int result3 = AttendanceLog::findStudent(0, emptyList, 101);
    assert(result3 == -1);
    std::cout << "[PASS] Edge Case: Empty list handled correctly." << std::endl;

    // --- 4. Boundary Case: First and Last ---
    int result4 = AttendanceLog::findStudent(5, normalList, 101); // First
    assert(result4 == 0);
    int result5 = AttendanceLog::findStudent(5, normalList, 509); // Last
    assert(result5 == 4);
    std::cout << "[PASS] Boundary Cases: First and Last elements found." << std::endl;

    // --- 5. Extreme/Stress Case ---
    // Large N (100,000) with target at the very end
    int largeN = 100000;
    std::vector<int> stressList(largeN);
    for(int i = 0; i < largeN; ++i) {
        stressList[i] = i; 
    }
    int resultStress = AttendanceLog::findStudent(largeN, stressList, 99999);
    assert(resultStress == 99999);
    std::cout << "[PASS] Stress Case: scanned 100,000 items successfully." << std::endl;

    std::cout << "All tests passed." << std::endl;
}

int main() {
    runTests();
    return 0;
}

```

---

## B. Complete Solution Code

*The following implementation uses C++ to solve the search problem. It prioritizes readability and standard competitive programming practices.*

```cpp
/**
 * Solution for "The Lost Student ID"
 * Implements Linear Search to locate a target integer in an unsorted array.
 */

#include <iostream>
#include <vector>

class AttendanceLog {
public:
    /**
     * Searches for a student ID in the attendance log.
     * * @param n The total number of students.
     * @param ids The vector containing student IDs.
     * @param target The student ID to search for.
     * @return The 0-based index of the target if found, otherwise -1.
     */
    static int findStudent(int n, const std::vector<int>& ids, int target) {
        // Handle empty list edge case immediately
        if (n == 0) {
            return -1;
        }

        // Iterate through the list sequentially
        for (int i = 0; i < n; ++i) {
            // Check if current ID matches target
            if (ids[i] == target) {
                return i; // Found! immediately return index
            }
        }

        // Target was not found after checking all elements
        return -1;
    }
};

```

## C. Complexity Analysis

### 1. Time Complexity

| Case | Complexity | Reasoning |
| :--- | :--- | :--- |
| **Best Case** | $O(1)$ | Target ID $K$ is at the very first index. The function returns after 1 comparison. |
| **Average Case** | $O(N)$ | Assuming uniform distribution, we scan $N/2$ elements. Constants are dropped in Big O. |
| **Worst Case** | $O(N)$ | Target is at the last position or not present. Every element must be checked. |

---

### 2. Space Complexity

* **Auxiliary Space:** $O(1)$
  * **Why:** Uses a fixed amount of extra memory for variables (like loop counter `i`) regardless of $N$.
* **Input Space:** $O(N)$
  * **Why:** Memory required to store the list of IDs. This is external to the algorithm's overhead.

---

### 3. Trade-offs

**Why use this over other methods?**
Since the data is unsorted, this is the most direct and necessary approach.

**What is sacrificed?**

* **Speed for large datasets:** We cannot skip elements like in Binary Search.
* **Search Optimization:** If we needed to search this list thousands of times, sorting it first ($O(N \log N)$) to enable $O(\log N)$ searches would be better. This logic optimizes for single-run efficiency.

***End of Solution File***
