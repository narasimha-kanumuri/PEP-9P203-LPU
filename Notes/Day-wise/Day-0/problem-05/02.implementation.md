# implementation.md

**Concepts Explained:** Conditional Branching • Relational Operators • Boolean Logic • Control Flow

---

## A. Solution Narrative (Design Intent)
Up to this point, our programs have been sequential—executing line 1, then line 2, then line 3, indiscriminately. This problem introduces **branching**: the ability of code to make a decision.

The "Design Intent" is to create a fork in the execution path. We have two inputs, $A$ and $B$, but we must produce only one output. The program must evaluate the relationship between $A$ and $B$ and "route" the flow of execution to print only the correct value. 

**Correctness is defined by the property:** $Output \ge A$ AND $Output \ge B$.

---

## B. Plain-English Core Questions
* **What information do I need at each step?**
    I need the current values of `num1` and `num2`.
* **When do I discard past information?**
    We don't discard; we select. Once the comparison is made, we effectively "discard" the smaller number from the output stream, though it remains in memory.
* **What guarantees correctness?**
    The **Law of Trichotomy**: For any two real numbers $a$ and $b$, exactly one of the following is true: $a < b$, $a = b$, or $a > b$. Our logic must cover all three states (though $a=b$ can be handled by the $a \ge b$ branch).
* **Why does this avoid brute force?**
    Brute force implies checking all possibilities without logic. Here, we perform a single $O(1)$ comparison to eliminate the wrong answer immediately.
* **What would break if constraints change?**
    If we needed to find the largest of 100 numbers, a simple if/else chain becomes unmanageable ($O(N)$ code size). We would need a loop and a state variable (`max_so_far`).

---

## C. High-Level Explanation
1.  **Ingest** two distinct integer values.
2.  **Evaluate** a relational condition: Is the first number greater than the second?
3.  **Branch**:
    * **True Path**: If the condition holds, designate the first number as the result.
    * **False Path**: If the condition fails, designate the second number as the result.
4.  **Output** the designated result.



---

## D. Detailed Logic Breakdown
1.  **Input Phase**: Read $a$, $b$.
2.  **Decision Phase**: Execute `if (a > b)`.
    * **Micro-operation**: The CPU subtracts $b$ from $a$ (CMP instruction) and checks the sign bit.
3.  **Path Selection**:
    * **If true**: Jump to code block printing $a$.
    * **If false**: Jump to code block printing $b$.
4.  **Convergence**: Both paths merge back to `return 0` (exit).

---

## E. Test Case Explanation Section

### 1. Test Case Table
| Input (A, B) | Expected Output | Why This Case Exists |
| :--- | :--- | :--- |
| 10, 20 | 20 | Standard: $B > A$. Tests the `else` path. |
| 50, 5 | 50 | Standard: $A > B$. Tests the `if` path. |
| 7, 7 | 7 | Edge: $A = B$. Tests strict vs. non-strict inequality. |

### 2. Test Case Trace Table (Input: 10, 20)
| Step | Operation | Variable a | Variable b | Boolean Expr a > b | Execution Path |
| :--- | :--- | :--- | :--- | :--- | :--- |
| 1 | Input | 10 | 20 | -- | -- |
| 2 | Compare | 10 | 20 | 10 > 20 $\rightarrow$ **FALSE** | Skip `if` block. |
| 3 | Else | 10 | 20 | -- | Enter `else` block. |
| 4 | Output | -- | -- | -- | Print `b` (20). |

### 3. Test Case Explanations
**Case 7, 7:** If we use `if (a > b)`, $7 > 7$ is False. The code falls to `else` and prints $b$ (which is 7). The result is numerically correct, even though they are equal.

---

## F. Variant Thinking
* **What if we cannot use if/else? (Ternary Operator)**
    We can use the conditional operator: `int max = (a > b) ? a : b;`. This condenses logic into a single expression.
* **What if we need the largest of 3 numbers?**
    Nested logic is risky. Better approach (**King of the Hill**):
    1. Assume `max = a`.
    2. `if (b > max) max = b;`
    3. `if (c > max) max = c;`
* **What if inputs are signed/unsigned mismatches?**
    Comparing a signed -1 with an unsigned 1 can lead to incorrect results because -1 is interpreted as a very large positive number in unsigned arithmetic. **Lesson:** Always compare like types.

---

## G. Visual Learning & Tools
* **Mental Model (The Train Switch):** Imagine a train track that splits. The switch is controlled by the condition ($A > B$). If true, the switch pulls Left. If false, it stays Right. The train cannot go both ways.
* **Visual Tool (Flowchart):**
    * **Diamond shape**: $a > b$?
    * **Arrow Right (No)**: Print $b$.
    * **Arrow Left (Yes)**: Print $a$.
    * Both arrows join at "End".



---
*End of Document*