# 1Ô∏è‚É£ problem.md ‚Äî Problem Definition

> **üîñ Header**
> **Concepts Involved:** Hashing, Sets, Early Exit, Existence Checking

---

## üìã Title
**The Duplicate Sensor Reading** *(Classic Logic: Contains Duplicate)*

### üìñ Problem Story / Context
You are developing firmware for an industrial temperature sensor network. Each sensor sends a stream of data packets to a central server. Each packet is tagged with a numeric **Timestamp ID**.

Under normal operation, every Timestamp ID received from a specific sensor should be unique (time moves forward). If the server receives the same Timestamp ID twice from the same sensor, it indicates a critical failure: either the sensor is malfunctioning (stuck in a loop) or a hacker is attempting a **"replay attack"** by resending old data.

Your task is to write a function that scans a list of incoming Timestamp IDs. It must return `true` immediately if any ID appears at least twice. It should return `false` only if every ID in the list is distinct.



---

### üì• Inputs
1.  **timestamps**: A vector of integers representing the stream of IDs.
2.  **Length $N$**: $0 \le N \le 10^5$.
3.  **Values**: IDs can be negative, zero, or positive (representing relative time offsets).

### üì§ Outputs
* **boolean**: `true` if any value appears at least twice.
* **boolean**: `false` if all elements are unique.

### ‚ö†Ô∏è Constraints
* **Time Complexity:** Must be $O(N)$.
    * *Why?* Sorting the array takes $O(N \log N)$. Brute force takes $O(N^2)$. For high-frequency sensors, we need the fastest possible check ($O(N)$).
* **Space Complexity:** $O(N)$ is acceptable to store history.

---

### üîç Edge-Case Thinking Prompts
* **Minimum Size:** What if the list is empty or has only one item? (Can a duplicate exist?)
* **Distance:** What if the duplicate is the very last element (e.g., `[1, 2, 3, ..., 1]`)?
* **Multiple Failures:** What if there are multiple different IDs that repeat?
* **Objective:** Does the specific count of duplicates matter, or just the presence of any duplicate?

---

### üß™ Sample Inputs & Outputs

**Sample 1**
* **Input:** `timestamps = [1, 2, 3, 1]`
* **Output:** `true`
* **Explanation:** The ID '1' appears twice. Malfunction detected.

**Sample 2**
* **Input:** `timestamps = [1, 2, 3, 4]`
* **Output:** `false`
* **Explanation:** All IDs are distinct. Sensor is healthy.

**Sample 3 (Immediate Fail)**
* **Input:** `timestamps = [1, 1, 1, 3, 3, 4, 3, 2, 4, 2]`
* **Output:** `true`
* **Explanation:** '1' is repeated. Note that multiple duplicates exist, but we return `true` as soon as we find the first one.

---

### üß† Thinking Like a Programmer

* **What must be tracked?**
    The history of every ID we have encountered so far.
* **The Decision:**
    For every new ID, we ask a simple question: *"Have I seen this before?"*
* **The Data Structure:**
    We need a structure that answers "Have I seen this?" in $O(1)$ time. Searching through a list (Array) would take $O(N)$ per item, leading to $O(N^2)$ total.
    
* **The Trade-off:**
    We trade **Memory** (to store the history) for **Speed** (instant lookup). This is the fundamental "Space-Time Trade-off" in algorithm design.

---
_End of Problem File_