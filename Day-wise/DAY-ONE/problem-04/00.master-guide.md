# 5ï¸âƒ£ master-guide.md

# ðŸ“˜ MASTER TEACHING PLAN: The Power Surge Windows

> **ðŸ”– Metadata**
> | Attribute | Details |
> | :--- | :--- |
> | **Topic** | Subarray Sum Equals K ($O(N)$ Strategy) |
> | **Core Concepts** | Prefix Sums, HashMaps, Frequency Counting, Difference Logic |
> | **Target Audience** | CS1 Students / Interview Preppers |
> | **Est. Time** | 45 Minutes |
> | **Prerequisites** | Arrays, Basic Hashing (Key-Value), Arithmetic |
> | **Follow-up** | Continuous Subarray Sum, Longest Subarray with Sum K |

---

## A. Time-Boxed Learning Flow (45 Min)
*This schedule enforces active derivation of the prefix sum difference formula.*

| Phase | Time | Goal | Mental Model |
| :--- | :--- | :--- | :--- |
| **1. The Wall** | 0â€“5 min | Realize that sliding window (Two Pointers) fails here. | **Negative Numbers Break Monotonicity:** You can't shrink the window effectively if adding a number might decrease the sum. |
| **2. The Transformation** | 5â€“15 min | Understand that a subarray sum is the difference between two cumulative sums. | **The Tape Measure:** Distance between 5m and 8m marks is 3m. $Sum(i, j) = Prefix(j) - Prefix(i-1)$. |
| **3. The Formula** | 15â€“20 min | Derive the lookup key. | **The Algebra:** We want $Current - Old = K$. Therefore, we look for $Old = Current - K$. |
| **4. Visual Trace** | 20â€“30 min | Trace map updates on paper. | **History Log:** The map records "how many times have I seen this cumulative sum before?" |
| **5. The Edge Case** | 30â€“35 min | The "Invisible Zero". | **Base Case:** Initialize `map[0] = 1` to handle subarrays starting at index 0. |
| **6. Complexity** | 35â€“45 min | Verify $O(N)$ time and space. | **One Pass:** We only touch each element once. |

---

## B. Teaching Process (Trainer View)

### 1. The "Trap" Question
Ask students: *"Can we use a Sliding Window (expand right, shrink left) to solve this?"*

* **Trap:** If the array contains negative numbers (e.g., `[1, -1, 1]`), expanding the window might decrease the sum. Monotonicity is lost. Sliding window only works for non-negative arrays.
* **Pivot:** "Since sliding window fails, we need a way to look up past states instantly. We need a Time Machine (HashMap)."



### 2. The "Tape Measure" Analogy
To explain $Sum(i, j) = P[j] - P[i-1]$:
1.  Imagine a tape measure stretched out.
2.  To measure a specific segment in the middle, you don't cut the tape.
3.  You take the reading at the end ($P[j]$) and subtract the reading at the start ($P[i-1]$).
* **Key Insight:** If the current reading is 15 and we want a segment of length 5 ($K$), we need to find if we ever saw a reading of 10 ($15 - 5$) previously.



### 3. The "Invisible Zero"
Ask: *"If my array is `[5]` and $K=5$, my Current Sum is 5. Current - K is 0. Is 0 in the map?"*
* **Issue:** If the map is empty, we miss this valid subarray that starts from the very beginning.
* **Fix:** Pre-insert `{0: 1}` into the map. This represents a "cumulative sum of 0" before the array even starts.

---

## C. Learning Process (Student View)
To master this effectively, consume the files in this strict order:
1.  **problem.md:** Understand the "Power Surge" scenario. Note the constraint regarding negative numbers.
2.  **implementation.md:** Study the Core Questions. Focus heavily on the "Algebra of History" section to understand the math derivation.
3.  **solution.md:** Analyze the code. Pay close attention to the order of operations: **Calculate Sum â†’ Lookup Difference â†’ Update Map.**
4.  **solution-implementation.md:** Review the Deep Explanations, specifically why `map[0] = 1` is mathematically required.
5.  **master-guide.md (This file):** Self-audit using the checklist below.

---

## D. Difficulty Progression Tag
* **Prerequisite Problem:** Two Sum (Finding a complement `Target - Current` in a map).
* **Current Level:** Medium-Hard. Requires translating a geometric problem (subarrays) into an algebraic one (prefix sums).
* **Next-Level Variant:** Subarray Sums Divisible by K (Requires modulo arithmetic logic).
* **Extension Challenge:** Maximum Size Subarray Sum Equals K (Store index instead of count in the map).



---

## E. Success Checklist
You are ready to move on only if you can answer **YES** to these:

* [ ] Can you derive why we look for `CurrentSum - K` and not `K - CurrentSum`?
* [ ] Can you explain why a sliding window approach fails when negative numbers exist?
* [ ] Do you understand why we initialize the HashMap with `{0: 1}`?
* [ ] Can you trace the state of the map for input `[1, -1, 1]` with $K=1$?
* [ ] Do you know that the map stores `{PrefixSum : Frequency}`?

---
_End of Master Guide_